#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
title: sizing_model
project: DSE-Mars-Reveal
date: 5/28/2020
author: lmaio
"""


import os
import sys
sys.path.append(os.path.join(os.path.abspath(os.curdir).split('DSE-Mars-Reveal', 1)[0], 'DSE-Mars-Reveal'))


from definitions import MarsReveal


import numpy as np

# M = MarsReveal()

class DisturbanceTorques():
    def __init__(self, file_in):
        self.M = MarsReveal()
        self.params = self.M.read_excel(file_in)


    def mag_torque(self, R, M, D):
        '''
        Args:
            R: radius from planet dipole to s/c [km]
            M: magnetic moment of planet    [tesla km^3]
            D: residual dipole of vehicle   [A m^2]

        Returns: magnetic torque on s/c

        '''
        B = 2 * M / (R**3)
        Tm = D * B
        return Tm, B


    def solar_torque(self, As, Cps, cg, i, q=0.6):
        '''
        Args:
            As: surface area
            Cps: center of solar pressure
            cg: center of gravity
            q: reflectance factor
            i: angle of incidence of the Sun

        Returns: Torque caused by solar radiation pressure

        '''
        F = self.M.solar_irr / self.M.c * As * (1+q) * np.cos (i)
        Tsp = F * (Cps - cg)
        return Tsp


    def gg_torque(self, R, Iz, Iy, theta):
        '''
        Args:
            R: orbit radius [km]
            Iz: MOI about z [kg m^2]
            Iy: MOI about y [kg m^2]
            theta: max deviation of z-axis from local vertical [rad]

        Returns: Tg, max gravity torque

        '''
        Tg = 3* self.M.mu_mars / (2 * R**3) * abs(Iz - Iy) * np.sin(2*theta)
        return Tg



    def det_mag_neg(self):
        '''Determine if Magnetic torques can be considered negligible on mars

        Returns: bool, true if mag torque negligible on mars orbit

        '''
        # Earth geostationary magnetic field
        E_r_bound  = 1500 # [km] altitude below which mag field plays significant role
        R_GEO = 6378 + E_r_bound  # [km] radius
        M_earth = 7.96 * 10**15 # [tesla *m^3]

        B_earth = self.mag_torque(R_GEO*10**3, M_earth, 0)[1] * 10**9 # [nT]

        B_mars = 1500 # max magnetic field mars [nT]

        return B_mars < B_earth

    def aero_torque(self, rho, Cd, A, V, Cpa, cg):
        '''Maximum aerodynamic torque

        Args:
            rho: atmospheric density
            Cd: drag coefficient (usually between 2 and 2.5)
            A: Surface area
            V: Spacecraft velocity
            Cpa: Center of aerodynamic pressure
            cg: cenger of gravity

        Returns:
            Maximum torque generated by aerodynamics
        '''
        F = 0.5 * (rho * Cd * A * V * Cpa * cg)
        Ta = F * (Cpa- cg)
        return Ta


    def surface_area(self, radius, height):
        return 2*radius*height


    def total_torque_orbiter(self):
        h_orbit = self.params['Astro']['h']

        # Magnetic torque
        Mag_mars = (5 * 10 ** -8) * (3397 ** 3) / 2  # [T km^3] from Elements of S/c Engineering, Table 5.5
        orbiter_dipole = 0 # [A m^2] residual dipole TODO: value unkown
        if self.det_mag_neg(): # Determine if mars field
            T_mag = 0
        else:
            T_mag = self.mag_torque(self.M.R_mars+h_orbit, Mag_mars, orbiter_dipole)

        # Solar torque
        SA = self.surface_area(self.params['Struct']['Orbiter radius'], self.params['Struct']['Orbiter height'])
        Cps = 0 # TODO: value unknown
        Cg = 0 # TODO: value unknown
        i = 0 # worst case scenario incidence angle
        T_sol = self.solar_torque(SA, Cps, Cg, i, q=0.6)

        # Gravity gradient torque
        Iz = 0 # TODO: value unknown
        Iy = 0 # TODO: value unknown
        theta = 0 # SC nadir pointing
        T_gg = self.gg_torque(self.M.R_mars+h_orbit, Iz, Iy, theta)

        # Aerodynamic torques
        rho = self.M.mars_atmos_props(h_orbit)[2]
        Cd = 2.5 # drag coefficient ( usually between 2 and 2.5) [SMAD]
        a = self.M.R_mars+h_orbit
        V = np.sqrt(self.M.mu_mars*(2/(self.M.R_mars+h_orbit) - 1/a))
        Cpa = 0 # TODO: value unknown
        Cg = 0 # TODO: value unknown
        T_aero = self.aero_torque(rho, Cd, SA, V, Cpa, Cg)

        # total torque
        T_tot = T_aero + T_gg + T_mag + T_sol
        return T_tot


class HardwareSizing(MarsReveal):
    def __init__(self, file_in):
        super().__init__()
        self.params = self.read_excel(file_in)

    def orbiter_moi_rough_max(self, mass, shape='cylinder'):
        '''Basic Moments of Inertia
        http://hyperphysics.phy-astr.gsu.edu/hbase/mi.html
        '''
        if shape != 'cylinder':
            raise NotImplementedError
        r = self.params['Strut']['Orbiter radius']
        h = self.params['Strut']['Orbiter height']
        # Along central axis
        Iz = 0.5 * mass * r**2

        # Along transverse axis
        Iy = .25* mass * r**2 + 1/12 * mass * h**2

        return max(Iz, Iy)

    def slew_torque_RW(self, angle, time):
        pass






if __name__ == '__main__':
    file_in = 'project/subsystems_design/AOCS/Sub_Output.xlsx'
    DT = DisturbanceTorques(file_in)
    T_D_orbiter = DT.total_torque_orbiter()

    print(T_D_orbiter)
    # # Subsystem Excel filepath, relative to project root.
    # file_in = 'project/subsystems_design/AOCS/Sub_Output.xlsx'
    #
    # #### Read all inputs ------------
    # in_params = M.read_excel(file_in)
    #
    # #### Access values --------------
    # # params_in['sheetname']['variable name']['column']
    # print(in_params['AOCS']['test 1']['value'])
    #
    #
    #
    #
    # #### Saving output parameters -------------------
    #
    # # Initialize existing sheet, ensures correct dictionary structure
    # out_params = M.read_excel(file_in, sheet_name='AOCS')
    #
    # # Modify values to the new calculated outputs
    # out_params['test 1']['value'] = 'new output 1'



    # # Save Values
    # file_out =  'project/subsystems_design/AOCS/Sub_Output - Copy.xlsx' # Likely same as above
    # M.save_excel(out_params, file_out, 'AOCS')


